# WB Parser Telegram Bot

Продвинутый парсер Wildberries с управлением через Telegram-бота, поддержкой многопоточности, гибкими фильтрами и асинхронной отчетностью.

## Ключевые возможности

*   **Telegram-бот для управления:**
    *   Просмотр и установка параметров парсинга (`/show`, `/set <ключ> <значение>`).
    *   Переключение boolean-параметров (`/toggle <ключ>`).
    *   Удобная настройка фильтров через inline-кнопки (`/filters`).
    *   Запуск (`/start_parsing`) и остановка (`/stop`) парсера.
    *   Получение уведомлений о прогрессе и итоговых отчетов с файлами (JSON, CSV, лог ошибок) прямо в Telegram.
*   **Режимы работы парсера (запускается из `main.py` или через бота):**
    *   Поиск по ключевому слову.
    *   Парсинг по URL категории.
    *   Обновление данных по списку артикулов из файла.
    *   Сбор случайных товаров.
    *   "Максимальный сбор": сбор всех товаров из поиска или категории.
    *   Интерактивное меню для запуска `main.py` напрямую.
*   **Гибкая фильтрация:**
    *   Диапазон цен.
    *   Минимальный рейтинг.
    *   Минимальное количество отзывов.
    *   Фильтр по бренду.
    *   Отбор товаров со скидкой "за отзыв" (учитывается, что текущая цена должна быть ниже цены со скидкой за отзыв).
*   **Технические особенности:**
    *   Многопроцессорный парсинг карточек товаров для ускорения работы.
    *   Использование Selenium с ChromeDriver.
    *   Поддержка User-Agent и прокси (с проверкой и ротацией).
    *   Асинхронная отправка прогресса в Telegram без блокировки основного процесса парсинга.
    *   Запись PID процесса парсера для корректной остановки.
    *   Подробное логирование работы бота и парсера.
    *   Сохранение результатов в форматах JSON и CSV.
    *   Сохранение файла `progress.json` для отслеживания статуса парсинга ботом.

## Структура проекта

```
.
├── bot.py                  # Telegram-бот (aiogram)
├── main.py                 # Основная логика парсера, CLI
├── parser.py               # Функции для Selenium, сбор ссылок и данных со страниц
├── filters.py              # Логика фильтрации товаров
├── utils.py                # Вспомогательные утилиты (прокси, user-agents, логи)
├── config.py               # Конфигурация (токены, пути, параметры по умолчанию)
├── telegram_notify.py      # Функции для отправки сообщений/файлов в Telegram (используется main.py при прямом запуске)
├── requirements.txt        # Зависимости Python
├── Dockerfile              # Файл для сборки Docker-образа
├── user_config.json        # Пользовательские настройки (создается и обновляется ботом)
├── parser_process.pid      # PID запущенного процесса парсера (создается ботом)
├── progress.json           # Файл с прогрессом парсинга (обновляется main.py, читается bot.py)
├── errors.log              # Лог ошибок отдельных URL при парсинге (имя файла настраивается)
├── main_parser.log         # Лог работы main.py
├── wb_parser.log           # Общий лог (используется utils.py)
└── README.md               # Этот файл
```

## Установка и настройка

### 1. Клонирование репозитория
```bash
git clone <URL_вашего_репозитория>
cd <имя_папки_проекта>
```

### 2. Создание и активация виртуального окружения
Рекомендуется использовать виртуальное окружение для изоляции зависимостей.
```bash
python -m venv venv
# Для Windows:
venv\Scripts\activate
# Для Linux/macOS:
source venv/bin/activate
```

### 3. Установка зависимостей
```bash
pip install -r requirements.txt
```
Это установит все необходимые Python-библиотеки, включая `aiogram`, `selenium`, `beautifulsoup4`, `pandas` и др.

### 4. Настройка ChromeDriver
Парсер использует Selenium с ChromeDriver. `webdriver-manager` попытается автоматически скачать и установить подходящую версию ChromeDriver.
Если возникнут проблемы, убедитесь, что у вас установлен Google Chrome, и при необходимости вручную скачайте ChromeDriver и укажите путь к нему.

### 5. Настройка Telegram-бота
1.  **Создайте бота в Telegram:**
    *   Откройте Telegram и найдите бота `@BotFather`.
    *   Отправьте команду `/newbot`.
    *   Следуйте инструкциям, чтобы задать имя и username для вашего бота.
    *   `@BotFather` выдаст вам **токен** для доступа к API Telegram. Скопируйте его.

2.  **Узнайте ваш Telegram Chat ID:**
    *   Найдите в Telegram бота `@userinfobot` (или аналогичного).
    *   Отправьте ему команду `/start`.
    *   Бот пришлет вам информацию, включая ваш `Chat ID`. Скопируйте его.

3.  **Внесите токен и Chat ID в `config.py`:**
    Откройте файл `config.py` и замените значения переменных `TELEGRAM_TOKEN` и `TELEGRAM_CHAT_ID`:
    ```python
    # Telegram
    TELEGRAM_TOKEN = "СЮДА_ВАШ_ТОКЕН_БОТА"
    TELEGRAM_CHAT_ID = "СЮДА_ВАШ_CHAT_ID" # Должен быть строкой
    ```
    **Важно:** `TELEGRAM_CHAT_ID` должен быть строкой, даже если это число. Например: `"123456789"`.

### 6. Настройка параметров по умолчанию (опционально)
В файле `config.py` вы можете изменить значения по умолчанию для различных параметров парсинга:
*   `DEFAULT_SEARCH_QUERY`, `DEFAULT_CATEGORY_URL`
*   `DEFAULT_MAX_PAGES`
*   Фильтры цен, рейтинга, отзывов (`DEFAULT_MIN_PRICE`, `DEFAULT_MAX_PRICE` и т.д.)
*   Количество потоков `DEFAULT_THREADS`
*   Имена файлов для результатов и логов (`DEFAULT_OUT_JSON`, `DEFAULT_OUT_CSV`, `DEFAULT_ERROR_LOG`)
*   Настройки прокси (`PROXY_LIST`, `ENABLE_PROXY`)
*   Использование cookies и списка User-Agent'ов.

### 7. Файлы User-Agents и Cookies (опционально)
*   **User Agents:** Если `ENABLE_USER_AGENT_LIST` в `config.py` установлено в `True` (по умолчанию), парсер будет пытаться брать случайные User-Agent'ы из файла, указанного в `USER_AGENT_FILE` (по умолчанию `useragents.txt`). Создайте этот файл и добавьте в него по одному User-Agent'у на строку. Если файл не найден или пуст, будет использован User-Agent из `fake-useragent` или запасной.
*   **Cookies:** Если `ENABLE_COOKIES` в `config.py` установлено в `True` (по умолчанию), парсер будет пытаться загружать cookies из файла, указанного в `COOKIES_FILE` (по умолчанию `cookies.json`). Этот файл должен быть в формате JSON, который может принять `driver.add_cookie()`. Пример:
    ```json
    [
      {
        "name": "cookie_name_1",
        "value": "cookie_value_1",
        "domain": ".wildberries.ru"
      },
      {
        "name": "cookie_name_2",
        "value": "cookie_value_2",
        "domain": ".wildberries.ru"
      }
    ]
    ```

### 8. Список прокси (опционально)
Если `ENABLE_PROXY` в `config.py` установлено в `True`, парсер будет использовать прокси.
Заполните список `PROXY_LIST` в `config.py` вашими прокси-серверами в формате `protocol://ip:port` или `protocol://user:pass@ip:port`.
```python
PROXY_LIST = [
    "http://proxy1.example.com:8080",
    "http://user:password@proxy2.example.com:3128",
    # ... другие прокси
]
```
Перед началом парсинга будет выполнена проверка работоспособности прокси.

## Запуск

### Запуск Telegram-бота
```bash
python bot.py
```
После запуска бота вы сможете взаимодействовать с ним в Telegram, используя описанные выше команды. Бот будет работать в фоновом режиме, ожидая ваших команд.

### Прямой запуск парсера (минуя бота)
Вы также можете запустить парсер напрямую из командной строки, используя `main.py`.
```bash
python main.py
```
При запуске без аргументов `main.py` предложит интерактивное меню для выбора режима и настройки параметров.

Вы также можете передавать аргументы командной строки. Например:
```bash
python main.py --search "умные часы" --pages 3 --min-price 1000 --max-price 5000
```
Для просмотра всех доступных аргументов:
```bash
python main.py --help
```

## Использование Docker (опционально)

Проект содержит `Dockerfile` для сборки Docker-образа.

### 1. Сборка образа
```bash
docker build -t wb-parser-bot .
```

### 2. Запуск контейнера
Перед запуском контейнера убедитесь, что вы правильно настроили `config.py`, особенно `TELEGRAM_TOKEN` и `TELEGRAM_CHAT_ID`. Вы можете либо вписать их прямо в `config.py` перед сборкой, либо смонтировать измененный `config.py` в контейнер при запуске, либо использовать переменные окружения (потребует доработки кода для чтения из env).

**Пример запуска с монтированием текущей директории (для сохранения результатов и логов на хосте):**
```bash
docker run -d --name wb-parser-container -v "%cd%:/app" wb-parser-bot
```
Для Linux/macOS:
```bash
docker run -d --name wb-parser-container -v "$(pwd):/app" wb-parser-bot
```
*   `-d` запускает контейнер в фоновом режиме.
*   `--name wb-parser-container` присваивает имя контейнеру.
*   `-v "%cd%:/app"` (для Windows) или `-v "$(pwd):/app"` (для Linux/macOS) монтирует текущую директорию (где находится ваш проект) в директорию `/app` внутри контейнера. Это позволит сохранять `user_config.json`, `results.json`, `results.csv`, `errors.log`, `main_parser.log`, `progress.json` и `wb_parser.log` на вашем хост-компьютере.

### Просмотр логов контейнера
```bash
docker logs wb-parser-container
# или для непрерывного просмотра
docker logs -f wb-parser-container
```

### Остановка контейнера
```bash
docker stop wb-parser-container
```

### Удаление контейнера
```bash
docker rm wb-parser-container
```

## Логирование

Проект использует несколько лог-файлов:
*   **Логи Telegram-бота (`bot.py`):** Выводятся в консоль и могут быть перенаправлены при запуске. `bot.py` также инициализирует базовый `logging` с выводом в консоль, который может быть использован другими модулями, если они не настроят свой собственный.
*   **`main_parser.log`:** Логи основной работы скрипта `main.py` (запуск, сбор ссылок, сводка).
*   **`errors.log`:** (имя настраивается через `config.py` или аргументы `main.py`) Логи ошибок, возникающих при парсинге отдельных URL товаров (например, капча, недоступность страницы, ошибки разбора данных).
*   **`wb_parser.log`:** Общий лог-файл, используемый утилитами (например, `utils.py` для логирования информации о прокси).

## Принцип работы связки `bot.py` и `main.py`

1.  Пользователь через `bot.py` запускает парсинг (`/start_parsing`).
2.  `bot.py` собирает актуальные параметры из `user_config.json`.
3.  `bot.py` запускает `main.py` как отдельный подпроцесс (`asyncio.create_subprocess_exec`), передавая ему параметры командной строки. PID процесса сохраняется в `parser_process.pid`.
4.  `main.py` выполняет парсинг:
    *   Собирает ссылки на товары.
    *   В многопроцессном режиме обрабатывает каждую ссылку (загружает страницу, извлекает данные, фильтрует).
    *   Периодически (после каждого батча) обновляет файл `progress.json` с текущим статусом (количество обработанных товаров, найденных, номер пакета, общее время).
    *   Логирует ошибки обработки URL в свой `errors.log`.
    *   По завершении сохраняет результаты в JSON и CSV.
5.  Параллельно в `bot.py` работает асинхронная задача `send_progress_updates`. Она периодически (раз в минуту):
    *   Проверяет, запущен ли еще процесс парсера (через `is_parser_running()` по PID).
    *   Если да, читает `progress.json`.
    *   Если данные в `progress.json` обновились, отправляет сообщение о прогрессе в Telegram.
6.  После завершения процесса `main.py`:
    *   `bot.py` отменяет задачу `send_progress_updates`.
    *   Удаляет `parser_process.pid`.
    *   Отправляет итоговые файлы (`results.json`, `results.csv`, `errors.log`) и сообщение о завершении в Telegram.

Такая архитектура позволяет боту оставаться отзывчивым, пока парсер работает в фоне, и предоставлять пользователю актуальную информацию о ходе процесса. 